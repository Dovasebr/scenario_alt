init:
    # Номер релиза сохранения, пустой по инициализации, в начале игры - присваивается номер релиза мода,
    # при загрузке:
    #  - если было сохранение с присвоением номера, при загрузке переменная будет взята из сохранения;
    #  - если загружается "старое" сохранение (до ввода процедуры контроля загрузок) - останется None 
    $ alt_save_release_no = None 

    $ alt_aicr_string = " "

# После загрузки файла переходим именно в это место. Определено механикой Ренпая - 
# если есть метка 'after_load' - переходить на нее. В классике и других модах такая метка не обнаружена
# Не путать со служебной меткой '_after_load'

label after_load:

    # читаем 'save_name' и ищем в строке "7ДЛ" - думаю, этого дл идентификации мода достаточно
    if save_name.find(u'7ДЛ') != -1: #Если нашли вхождение '7ДЛ' в имени сохранения игры

        # пишем версию 7дл в трейсбеках
        if renpy.version(tuple=False) == "Ren'Py 6.16.3.502":
            $ config.version = "1.1 + 7DL v.%s" % (alt_release_no)
        else:
            $ config.version = "1.2 + 7DL v.%s" % (alt_release_no)
            $ save_names_known()

        # Проверяем, совпадают ли версии сохранения и мода и есть ли версия сохранения в списке совместимых
        if (alt_release_no != alt_save_release_no) and (alt_save_release_no not in alt_compatible_release_no): # и если сохранение несовместимо

            python: # генерируем строку с номерами версий
                alt_aicr_string = (u"ЗАГРУЖАЕМАЯ ВЕРСИЯ СОХРАНЕНИЯ (%s) НЕСОВМЕСТИМА С ЭТОЙ ВЕРСИЕЙ МОДА (%s)") % (alt_save_release_no, alt_release_no)
            call screen alt_incompatible_release # и показываем экран предупреждения с выбором вариантов
        else:
            pass # версии совпали, играем дальше
    else: 
        pass # это не 7ДЛ, играем дальше

label alt_continue_game:
    return # .. и если все нормально - возвращаемся в игру